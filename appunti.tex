\documentclass[a4paper,11pt]{report}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}

\title{Dependable Distributed Systems}
\author{Ida Francesca Benvenuto}
\date{novembre 2025}

\begin{document}

\maketitle
\chapter{Failure Detection (7)}
Failure Detectors (FD) are mechanisms used in distributed systems to provide information about the status of processes, specifically whether they are operational (correct) or have failed (crashed). They help to overcome the challenges posed by asynchrony and failures in distributed systems.
\section{Timing assumptions}
Failure Detectors can be classified based on the timing assumptions they make about the system:
\begin{itemize}
    \item \textbf{Synchronous FD:} Assume known upper bounds on message transmission times and processing times. They can provide accurate information about process failures.
    \item \textbf{Asynchronous FD:} Do not assume any timing bounds. They may provide inaccurate information, leading to false suspicions of process failures.
    \item \textbf{Partially Synchronous FD:} Assume that the system is asynchronous but eventually becomes synchronous. They can provide more reliable information over time.
\end{itemize}
manipulating the timing assumptions allows to design failure detectors that can provide different levels of accuracy and reliability in detecting process failures.
the time managment can be :
\begin{itemize}
    \item \textbf{Explicit:} Using timeouts to detect failures. If a process does not respond within a specified timeout period, it is suspected to have failed.
    \item \textbf{Implicit:} Relying on the absence of expected messages to infer failures. If a process does not send expected messages, it is suspected to have failed.
\end{itemize}
\section{Failure Detector Abstraction}
A Failure Detector (FD) is an abstraction that provides processes with information about the status of other processes in the system. It can be modeled as a module that generates two types of events:
\begin{itemize}
    \item \textbf{Suspect Event:} Indicates that a process is suspected to have failed.
    \item \textbf{Restore Event:} Indicates that a previously suspected process is now considered operational again.
\end{itemize}
it generally is defined by two properties:
\begin{itemize}
    \item \textbf{Completeness:} Ensures that all crashed processes are eventually suspected by all correct processes.
    \item \textbf{Accuracy:} Ensures that no correct process is ever suspected.
\end{itemize}
Based on these properties, failure detectors can be classified into different types:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imm/Screenshot 2025-11-30 alle 17.55.08.png}
    \caption{Failure Detector types based on Completeness and Accuracy}
\end{figure}
\textbf{Observations:}
\begin{itemize}
    \item Strong completeness means that eventually every crashed process is permanently suspected by every correct process.
    \item Weak completeness means that eventually every crashed process is permanently suspected by at least one correct process.
    \item Strong accuracy means that no correct process is ever suspected.
    \item Weak accuracy means that there is at least one correct process that is never suspected.
    \item Eventual strong accuracy means that after some time, no correct process is suspected.
    \item Eventual weak accuracy means that after some time, there is at least one correct process that is never suspected.
\end{itemize}
weakness guarantees that there is at least one correct process that is never suspected, while strong guarantees that no correct process is ever suspected.
Partially speacking, this could be difficult to achieve and thus it is worth to consider weaker forms of accuracy.In particular, eventual accuracy properties are often more practical in real-world distributed systems, where temporary network issues or delays can lead to false suspicions of process failures.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{imm/Screenshot 2025-11-30 alle 18.05.41.png}
    \caption{Failure Detector properties}
\end{figure}
\section{Perfect Failure Detector (P)}
\subsection*{System model}
We consider a distributed system with the following assumptions.
\begin{itemize}
    \item \textbf{Synchronous System}
    \item \textbf{Crash Failures:} Processes can fail by \emph{crash}: a crashed process stops executing its algorithm forever, but they can't behave maliciously.(bizantine failures are not considered here)
\end{itemize}
using its own clock and the bounds of synchronous model, a process can infer if another process is crashed or just slow.
\subsection*{specification of Perfect Failure Detector}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imm/Screenshot 2025-11-30 alle 18.25.47.png}
    \caption{Perfect Failure Detector properties}
\end{figure}
\subsection*{implementation of Perfect Failure Detector}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-11-30 alle 18.29.07.png}
    \caption{Perfect Failure Detector implementation}
\end{figure}

\subsubsection*{Initialization}
When the system starts (upon event $\langle p, \text{Init} \rangle$):
\begin{itemize}
    \item $\textit{alive} := \Pi$ --- Initialize the set of all processes
    \item $\textit{detected} := \emptyset$ --- Initialize the set of detected crashed processes as empty
    \item Set a periodic timer to trigger every $\Delta + \Phi$ time units
\end{itemize}
\subsubsection*{Main Event Handlers}
\begin{itemize}
    \item \textbf{Timer Event:} When the timer triggers (upon event $\langle p, \text{timeout} \rangle$):
    \begin{verbatim}
    for each process p in Pi do
      if p not in alive and p not in detected then
        detected := detected union {p};
        trigger <fd, Suspect | p>;
      send heartbeat message to p;
    alive := empty set;
    \end{verbatim}
    The process checks for processes that did not respond with a heartbeat and suspects them if they are not already suspected. It then sends heartbeat messages to all processes and resets the alive set.
    
    \item \textbf{Heartbeat Message Event:} When a heartbeat message is received from process $q$ (upon event $\langle p, \text{Heartbeat} | q \rangle$):
    \begin{verbatim}
    alive := alive union {q};

    \end{verbatim}
    The process that replied, they adds $q$ to the alive set. 
\end{itemize}
es:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Immagine JPEG-4A77-8056-27-0.jpeg}
    \caption{Example of Perfect Failure Detector execution}
\end{figure}
\subsubsection*{correctness}
\begin{itemize}
    \item \textbf{Strong Completeness:} Eventually, every crashed process is permanently suspected by every correct process. This is ensured because crashed processes will not send heartbeat messages, leading to their suspicion.
    \item \textbf{Strong Accuracy:} No correct process is ever suspected. This is ensured because correct processes will always respond with heartbeat messages within the expected time frame.
\end{itemize}
if the timeout is very short, correct processes may be suspected due to network delays or processing time variations.
\newline
if the timeout is very long, crashed processes may not be suspected promptly, leading to delays in failure detection.
\newline
Thus, the choice of timeout value is crucial for the effectiveness of the Perfect Failure Detector.
\section{Eventually Perfect Failure Detector ($\Diamond P$)}
\subsection*{System model}
We consider a distributed system with the following assumptions.
\begin{itemize}
    \item \textbf{Partially Synchronous System:} The system is asynchronous but eventually becomes synchronous.
    \item \textbf{Crash Failures:} Processes can fail by \emph{crash}: a crashed process stops executing its algorithm forever, but they can't behave maliciously. (Byzantine failures are not considered here)
    \item \textbf{Perfect point to point links}
\end{itemize}
Crashed processes can be detected only after an unknown time $t$; before time $t$ there could be false suspicions (it behaves like an asynchronous system).

\subsection*{Basic Construction Rules}
An Eventually Perfect Failure Detector uses timeouts to suspect processes that did not send expected messages:
\begin{itemize}
    \item \textbf{Suspicion mechanism:} A suspect may be wrong. A process $p_i$ may suspect another one $p_j$ if the current timeout is too short.
    \item \textbf{Ready to change judgment:} $\Diamond P$ is ready to change its judgment as soon as it receives a message from $p_j$. In this case, the timeout value is updated to accommodate for longer delays.
    \item \textbf{Permanent suspicion:} If $p_j$ has actually crashed, $p_i$ does not change its judgment anymore.
\end{itemize}

The key difference from Perfect FD is that Eventually Perfect FD can make mistakes initially (false suspicions), but eventually stabilizes and behaves correctly once the system becomes synchronous and timeouts are adjusted appropriately.

\subsection*{specification of Eventually Perfect Failure Detector}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imm/Screenshot 2025-11-30 alle 20.14.26.png}
    \caption{Eventually Perfect Failure Detector properties}
\end{figure}
\subsection*{implementation of Eventually Perfect Failure Detector}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-11-30 alle 20.20.51.png}
    \caption{Eventually Perfect Failure Detector implementation}
\end{figure}
\subsubsection*{Main Event Handlers}
\begin{itemize}
    \item \textbf{Timer Event:} When the timer triggers (upon event $\langle p, \text{timeout} \rangle$):
    \begin{verbatim}
    If there exists a process q in alive and q in suspected then
        delay= delay + d;
    for each process p in Pi do
      if p not in alive and p not in suspected then
        suspected := suspected union {p};
        trigger <fd, Suspect | p>;
        send heartbeat message to p;
      if p in alive and p in suspected then
        suspected := suspected \ {p};
        trigger <fd, Restore | p>;
        send heartbeat message to p;
    alive := empty set;
    start timer with delay;
    \end{verbatim}
    The process checks for processes that did not respond with a heartbeat and suspects them if they are not already suspected. If a previously suspected process responds, it is restored. The timeout delay is adjusted based on the suspicion status.
    \subsection*{example}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{imm/Immagine JPEG-4C4B-B34A-EA-0.jpeg}
        \caption{Example of Eventually Perfect Failure Detector execution}
    \end{figure}
\end{itemize}
\section{correctness}
\begin{itemize}
    \item \textbf{Strong Completeness:} If a process crashes, it will eventually be suspected by all correct processes. This is ensured because crashed processes will not send heartbeat messages, leading to their suspicion.
    \item \textbf{Eventual Strong Accuracy:} After some unknown time, no correct process is suspected. This is ensured because once the system becomes synchronous and timeouts are adjusted, correct processes will always respond with heartbeat messages within the expected time frame.
\end{itemize}

\chapter{Leadership Election (7-b)}
Leadership Election is a fundamental problem in distributed systems where processes need to agree on a single process to act as the leader or coordinator for certain tasks. The leader is responsible for making decisions, coordinating actions, and managing resources among the processes.
in the asynchronous system with crash failures,the system stabilizes after some unknown time t, and after t there is a correct process that is never suspected.
thus there are two opstions:
\begin{itemize}
    \item put the assumption on the system (Including links and processes)
    \item create a separate abstraction that encapsulates the assumption 
\end{itemize}
incapsulating the assumption in a separate abstraction is better because it allows to separate concerns, making the system more modular and easier to understand. While do all in a unique algorithm can lead to complex and hard to proof.
thus, we can use a single correct process that monitoring features of the system to elect a leader.
we can use several oracle(called leader election module) that provide information about the processes.
\section {Leader Election}
\subsection*{specification of Leader Election}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 15.33.44.png}
    \caption{Leader Election properties}
\end{figure}
\subsection*{implementation of Leader Election using Eventually Perfect Failure Detector}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 15.36.01.png}
    \caption{Leader Election implementation using Eventually Perfect Failure Detector}
\end{figure}
\subsubsection*{Main Event Handlers}
\begin{itemize}
    \item \textbf{Initialization Event:} When the system starts (upon event $\langle p, \text{Init} \rangle$):
    \begin{verbatim}
        leader != maxrank(Pi / suspected) - the process tha have the highest rank among those not suspected;
        leader := max(Pi/ suspected);
        trigger <le, NewLeader | leader>;
    \end{verbatim}
    The process selects the process with the highest rank among those not suspected as the leader and triggers a NewLeader event.
\end{itemize}
\subsection*{example}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 15.44.40.png}
    \caption{Example of Leader Election execution}
\end{figure}
the correctness is guaranteed only if there is perfect failure detector. otherwise, there are two possibilities:
\begin{itemize}
    \item best scenario: suspect wrongly a crashed process, but the processes that continue to work are correct.
    \item worst scenario: FALSE POSITIVE, 2 processes could belive to have 2 different leaders.
\end{itemize}
\section{Eventual Leader Election}
\subsection*{specification of Eventual Leader Election}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 15.49.56.png}
    \caption{Eventual Leader Election properties}
\end{figure}

\subsubsection*{Key Properties and Behavior}
At first, every process may believe in a different leader, but after some unknown time $t$, all correct processes agree on the same correct leader.

\textbf{How it works:}
\begin{itemize}
    \item Every process decides a leader based on the information provided by the Eventually Perfect Failure Detector ($\Diamond P$).
    \item After time $t$ (when the system stabilizes), all correct processes agree on the same correct leader.
    \item We don't know when this time $t$ is, and during this initial period, crashed processes can be elected as leaders (false positives).
    \item Once the system stabilizes and elects a leader, the leader is not changed until it crashes. This stable leader is called \textbf{STABILIZED}.
\end{itemize}

\textbf{Important assumption:} There always exists at least one correct process.
\subsection*{implementation of Eventual Leader Election using Eventually Perfect Failure Detector}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 16.08.24.png}
    \caption{Eventual Leader Election implementation using Eventually Perfect Failure Detector}     
\end{figure}
Example:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 16.11.03.png}
    \caption{Example of Eventual Leader Election execution}
\end{figure}
\section{ eventual leader election with Crash-Recovery}
chrash-recovery model: processes can crash and later recover, resuming their operations from the state they had before crashing.
in this system the correct processes are p that never crash or that crash, recover and never crash again.
\subsection*{implementation of Eventual Leader Election in Crash-Recovery model}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 16.16.03.png}
    \caption{Eventual Leader Election implementation in Crash-Recovery model}
\end{figure}   
\subsubsection*{Initialization}
When the system starts (upon event $\langle p, \text{Init} \rangle$):
\begin{verbatim}
    epoch := 0; -- Initialize epoch counter(how many times the process has crashed and recovered)
    store(epoch); -- Store the epoch counter in stable storage
    candidates := empty set; -- Initialize the set of candidate leaders as empty
    trigger < \Omega , Recovery | >; -- Trigger a Recovery event
\end{verbatim}
\subsubsection*{trigger Recovery}
When a process recovers (upon event $\langle p, \text{Recovery} \rangle$):
\begin{verbatim}
    leader := maxrank(Pi) -- Select the process with the highest rank as the leader
    trigger <le, trust | leader>; -- Trigger a trust event with the selected leader
    delay := deltha; -- Initialize the delay for heartbeat messages
    retrieve(epoch); -- Retrieve the epoch counter from stable storage
    epoch := epoch + 1; -- Increment the epoch counter
    store(epoch); -- Store the updated epoch counter in stable storage
    forall q in Pi do
        send [HEARTBEAT, epoch] to q; -- Send heartbeat messages to all processes with the current epoch
    candidates := empty set; -- Reset the set of candidate leaders
    start timer with delay; -- Start the timer with the specified delay
\end{verbatim}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 16.22.32.png}
    \caption{Eventual Leader Election implementation in Crash-Recovery model}
\end{figure}  
\subsubsection*{ Timeout Event}
When the timer triggers (upon event $\langle p, \text{timeout} \rangle$):   
\begin{verbatim}
    elect new leader from candidates; 
    if the new leader != leader then. -- If a new leader is elected
        leader := new leader;
        trigger <le, trust | leader>;
    for all q in Pi do
        send [HEARTBEAT, epoch] to q; -- Send heartbeat messages to all processes with the current epoch
    candidates := empty set; -- Reset the set of candidate leaders
    start timer with delay; -- Start the timer with the specified delay
\end{verbatim}
\subsubsection*{example}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 16.34.26.png}
    \caption{Example of Eventual Leader Election execution in Crash-Recovery model}
\end{figure}
the timer is incremented when a process receive a heartbeat from a process with higher epoch.(p1)
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 16.37.03.png}
    \caption{Example of Eventual Leader Election execution in Crash-Recovery model - part 2}    
\end{figure}
after the restore of p1, the epoch is incremented and p2 become the leader.

\chapter{ Broadcast Communication(9-10)}
Up to now, the comunication model used is between two processes (like clien-server enviroment).
In distributed systems, it is often necessary to communicate with multiple processes simultaneously. Broadcast communication is a method that allows a process to send a message to all other processes in the system.
\section{Best Effort Broadcast (BEB)}
Best Effort Broadcast (BEB) is a communication primitive that allows a process to send a message to all other processes in a distributed system with the following properties:
\begin{itemize}
    \item \textbf{Validity:} If a correct process broadcasts a message, then all correct processes eventually deliver that message.
    \item \textbf{No Duplication:} No message is delivered more than once to any process.
    \item \textbf{No Creation:} No message is delivered unless it was previously broadcast by some process.
\end{itemize}
\subsection*{specification of Best Effort Broadcast}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 16.45.59.png}
    \caption{Best Effort Broadcast properties}
\end{figure}
\subsection*{implementation of Best Effort Broadcast}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 16.47.13.png}
    \caption{Best Effort Broadcast implementation}
\end{figure}
\subsubsection*{correctness}
\begin{itemize}
    \item \textbf{Validity:} If a correct process broadcasts a message, it sends the message to all processes. In our model there are perfect point-to-point links, so all correct processes will eventually receive and deliver the message.
    \item \textbf{No Duplication:} Each process maintains a set of delivered messages. A message is only delivered if it has not been delivered before, ensuring no duplication.
    \item \textbf{No Creation:} perfect point-to-point links ensure that messages are only delivered if they were sent by some process. Since processes only deliver messages they receive, no message can be created out of thin air.
\end{itemize}
\section{ (Regular) Reliable Broadcast(RB)}
Reliable Broadcast (RB) is a communication primitive that extends Best Effort Broadcast by providing stronger guarantees in the presence of process failures. It ensures that messages are delivered reliably even if some processes crash.
the specification of RB are the same of BEB plus:
\begin{itemize}
    \item \textbf{Agreement:} If a correct process delivers a message, then all correct processes eventually deliver that message.
\end{itemize}
difference:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 17.21.12.png}
    \caption{Difference between Best Effort Broadcast and Reliable Broadcast}
\end{figure}
\section*{implementation of Reliable Broadcast IN Synchronous System }
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 17.22.56.png}
    \caption{Reliable Broadcast implementation in Synchronous System}
\end{figure}
\subsubsection*{initialization}
When the system starts (upon event $\langle p, \text{Init} \rangle$):
\begin{verbatim}
    correct := Pi; -- Initialize the set of correct processes (all processes)
    from [p] := empty set[n]; -- Array to track messages received from each process
\end{verbatim}
\subsubsection*{deliver event}
When a message is delivered (upon event $\langle beb, \text{Deliver} | q, [DATA, s, m]\rangle$):
\begin{verbatim}
    if m not in from[q] then -- If the message has not been received from process q before
        from[q] := from[q] union {m}; -- Add the message to the set of messages received from process q
        trigger <rb, Deliver | s, m>; -- Trigger the delivery event for the reliable broadcast
        if s is not in correct then -- If the sender process s is not in the set of correct processes
            trigger <beb, Broadcast | [DATA, s, m]>; -- Trigger the delivery event for the reliable broadcast
\end{verbatim}
\subsubsection*{example}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 17.34.59.png}
    \caption{Example of Reliable Broadcast execution in Asynchronous System}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 17.36.33.png}
    \caption{Example of Reliable Broadcast execution in Asynchronous System}
\end{figure}
\subsubsection*{Lazy Reliable Broadcast}
in the best scenario, the RB implementation can generate 1 BEB message per RB message .
\newline
in the worst scenario, the RB implementation can generate N-1 BEB messages per RB message.
\newline
if the failure detector is not perfect, the algorithm is not correct, because it may trigger unnecessary retransmissions or fail to detect crashed processes accurately.
\section{Reliable Broadcast (RB) in Asinchronous System}
\subsection*{implementation of Reliable Broadcast IN Asynchronous System }
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 17.43.15.png}
    \caption{Reliable Broadcast implementation in Asynchronous System}
\end{figure}
in this case the best scenario is equal to worst scenario = N BEB messages per RB message, because every message is retransmitted by every process.
\section{ Uniform Reliable Broadcast (URB)}
Uniform Reliable Broadcast (URB) is a communication primitive that extends Reliable Broadcast by providing even stronger guarantees, particularly in the presence of process failures. It ensures that messages are delivered uniformly across all processes, meaning that if any process delivers a message, then all correct processes will eventually deliver that message.
thus, the specification of URB are the same of RB plus:
\begin{itemize}
    \item \textbf{Uniform Agreement:} If any process (correct or faulty) delivers a message, then all correct processes eventually deliver that message.
\end{itemize}
difference:
\begin{figure}[H]
    \centering
    \includegraphics[width=1.1\textwidth]{imm/Screenshot 2025-12-01 alle 17.49.36.png}
    \caption{Difference between Reliable Broadcast and Uniform Reliable Broadcast}
\end{figure}
\subsection*{implementation of Uniform Reliable Broadcast IN Synchronous System }
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-01 alle 17.50.30.png}
    \caption{Uniform Reliable Broadcast implementation in Synchronous System}
\end{figure}
\begin{verbatim}
    pending := empty set; -- Initialize the set of pending messages as empty
\end{verbatim}
when the message have to be broadcasted by URB, it is added to the pending set.

\begin{verbatim}
upon event <beb, Deliver | q, [DATA, s, m]> do
    ack[m] := ack[m] union {q}; -- Add the process q to the set of acknowledgments for message m
    if m not pending then -- If the message m is not in the pending set
        pending := pending union {m}; -- Add the message m to the pending set
        trigger <beb, broadcast | s, m>; 
\end{verbatim}

\subsection*{example}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-02 alle 13.14.23.png}
    \caption{Example of Uniform Reliable Broadcast execution in Synchronous System}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-02 alle 13.27.02.png}
    \caption{Example of Uniform Reliable Broadcast execution in Synchronous System - part 2}
\end{figure}    
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-02 alle 13.27.19.png}
    \caption{Example of Uniform Reliable Broadcast execution in Synchronous System - part 3}
\end{figure}
\section{Implementation of Uniform Reliable Broadcast in Asynchronous Systems}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-02 alle 13.31.39.png}
    \caption{Uniform Reliable Broadcast implementation in Asynchronous System}
\end{figure}
MANCA
\section{Probabilistic Broadcast (PB)}
Probabilistic Broadcast (PB) is a communication primitive that allows a process to send a message to all other processes in a distributed system with probabilistic guarantees. Unlike traditional broadcast methods that provide deterministic guarantees, PB relies on probabilistic techniques to ensure that messages are delivered to a large fraction of processes with high probability.
the ack mechanism used in RB is not scalable because it requires maintaining an acknowledgment set for each message, which can become large in systems with many processes. 
The probabilistic approach reduces the overhead associated with acknowledgments by allowing processes to make decisions based on probabilistic criteria rather than waiting for explicit acknowledgments from all processes.
\subsection*{specification of Probabilistic Broadcast}
the specification of PB includes the following properties:
\begin{itemize}
    \item \textbf{Probabilistic Validity:} If a correct process broadcasts a message, then with high probability, a large fraction of correct processes eventually deliver that message.
    \item \textbf{No Duplication:} No message is delivered more than once to any process.
    \item \textbf{No Creation:} No message is delivered unless it was previously broadcast by some process.
\end{itemize}
\subsubsection*{gossip Dissemination}
Gossip dissemination is a technique used in probabilistic broadcast to spread messages throughout a distributed system. In this approach, each process randomly selects a subset of other processes to which it forwards the message, creating a "gossip" effect that helps disseminate the message efficiently.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-02 alle 14.38.18.png}
    \caption{Gossip Dissemination in Probabilistic Broadcast}
\end{figure}
\section*{implementation of Eager Probabilistic Broadcast}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-12-02 alle 14.38.58.png}
    \caption{Eager Probabilistic Broadcast implementation}
\end{figure}
\chapter{Consensus (11)}
\section{Consensus Problem}
The consensus problem in distributed systems involves a set of processes that must agree on a single value.
\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{imm/Screenshot 2025-11-25 alle 20.22.09.png}
    \caption{Consensus Problem}
\end{figure}
\section{consensus specification}
The consensus problem is defined by the following properties:
\begin{itemize}
    \item \textbf{Termination:} Every correct process eventually decides on a value.
    \item \textbf{Agreement:} No two correct processes decide on different values.
    \item \textbf{Validity:} If all correct processes propose the same value $v$, then any correct process that decides must decide $v$.
    \item \textbf{Integrity:} No correct process decides more than once.
\end{itemize}
\subsection*{Impossibility of Consensus in Asynchronous Systems with Failures}
In an asynchronous distributed system where processes can fail by crashing, it is impossible to design a deterministic consensus algorithm that satisfies all the properties of termination, agreement, validity, and integrity.
\newline
This result is known as the FLP impossibility theorem, named after Fischer, Lynch, and Paterson.The key intuition behind the FLP impossibility result is that in an asynchronous system, there is no upper bound on message delivery times or process execution speeds.
\section{Consensus Implementation in Synchronous Systems}
\subsection*{Flooding-based Consensus Algorithm}
In a synchronous system, we can implement a consensus algorithm using a flooding-based approach.All processes exchange their proposed values in rounds, and after a fixed number of rounds, they decide on a value based on the received proposals.
the rounds are fundamental because they provide a structured way for processes to communicate and ensure that all correct processes have the opportunity to share their proposed values before making a decision.(in this way we are sure that there aren't lost values)
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-11-25 alle 20.43.55.png}
    \caption{Flooding-based Consensus Algorithm}
\end{figure}

\section{Algorithm Description}

\subsection{Initialization}
When the system starts (upon event $\langle c, \text{Init} \rangle$):
\begin{itemize}
    \item $\textit{correct} := \Pi$ --- Initialize the set of correct processes (all processes)
    \item $\textit{round} := 1$ --- Start from round 1
    \item $\textit{decision} := \bot$ --- The decision is still empty ($\bot$ means ``not decided'')
    \item $\textit{receivedFrom}[r] := [\emptyset]^N$ --- Array tracking from which processes we have received messages for each round
    \item $\textit{proposals}[r] := [\emptyset]^N$ --- Array tracking the proposals received for each round
\end{itemize}

\subsection{Main Event Handlers}

\subsubsection{Propose Event}
When a process proposes a value:
\begin{verbatim}
upon event <c, Propose | v> do
  proposals[1] := proposals[1] union {v};
  trigger <beb, Broadcast | [PROPOSAL, 1, proposals[1]]>;
\end{verbatim}
The process adds its initial value to the proposals of round 1 and broadcasts it to all processes.

\subsubsection{Crash Event}
When the Failure Detector detects a crash:
\begin{verbatim}
upon event <P, Crash | p> do
  correct := correct \ {p};
\end{verbatim}
Removes the process from the set of correct processes.

\subsubsection{Deliver Event}
When a PROPOSAL is received:
\begin{verbatim}
upon event <beb, Deliver | p, [PROPOSAL, r, ps]> do
  receivedFrom[r] := receivedFrom[r] union {p};
  proposals[r] := proposals[r] union ps;
\end{verbatim}
Updates the list of processes from which messages have been received and merges the received proposals.

\subsection{Decision Logic}
The crucial logic for deciding:
\begin{verbatim}
upon correct subseteq receivedFrom[round] AND decision = bottom do
  if receivedFrom[round] = receivedFrom[round-1] then
    decision := min(proposals[round]);
    trigger <beb, Broadcast | [DECIDED, decision]>;
    trigger <c, Decide | decision>;
  else
    round := round + 1;
    trigger <beb, Broadcast | [PROPOSAL, round, proposals[round-1]]>;
\end{verbatim}

This is the most important part:
\begin{itemize}
    \item \textbf{Waiting condition:} The process waits until it has received messages from all correct processes ($\textit{correct} \subseteq \textit{receivedFrom}[\textit{round}]$)
    \item \textbf{Stability:} If the set of processes from which messages were received in this round is the same as in the previous round (no new crashes), we can trust the data
    \item \textbf{Decision:} Chooses the minimum value among the received proposals (deterministic function common to all processes, can be replaced with other functions)
    \item \textbf{Decision broadcast:} Communicates the decided value to all other processes
    \item \textbf{Else:} If the set changes (new crash detected), increment the round and continue
\end{itemize}

\subsection{Receiving DECIDED}
\begin{verbatim}
upon event <beb, Deliver | p, [DECIDED, v]> 
  such that p in correct AND decision = bottom do
  decision := v;
  trigger <beb, Broadcast | [DECIDED, decision]>;
  trigger <c, Decide | decision>;
\end{verbatim}
If a correct process communicates the decided value and the receiving process has not yet decided, it decides this value.

\subsection{Practical Example}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-11-25 alle 21.04.25.png}
    \caption{Example of Consensus Algorithm Execution}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-11-25 alle 21.10.31.png}
    \caption{P3 decide the min value after the decision of p1}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{imm/Screenshot 2025-11-25 alle 21.08.58.png}
    \caption{p2 is the only one thet can decide but crash before the broadcast of the value, so P1 and P3 go to the next round and decide an other value}
\end{figure}

\section{Uniform Consensus Specification}
The difference between uniform consensus and (non-uniform) consensus is that uniform consensus requires \textbf{Uniform Agreement}: no two processes (correct or faulty) can decide different values. In standard consensus, only correct processes are required to agree, meaning a faulty process may decide a different value before crashing.
in the algorithm the decision is choseen at the round N, (at the end) and the set of proposals is the same for all processes, so also faulty processes decide the same value of correct processes.
\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{imm/Screenshot 2025-11-25 alle 22.55.28.png}
    \caption{Uniform Consensus properties}
\end{figure}
\subsubsection*{Example}
\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{imm/Screenshot 2025-11-25 alle 22.59.09.png}
    \caption{at the round 3 there is a decision, that is 5 becaus when start a new round the receivedFrom set is = 0}
\end{figure}
\chapter{Paxos (12)}
Paxos is a consensus algorithm designed for asynchronous distributed systems with crash failures.
The safety is always guaranteed, while the liveness is guaranteed only under some conditions (like eventual message delivery and a majority of correct processes).

\section{Assumptions}
\begin{itemize}
    \item \textbf{Agents:} Operate at arbitrary speed, may fail by stopping (and may restart).
    \begin{itemize}
        \item \textbf{Observation:} Since all agents may fail after a value is chosen and then restart, a solution is impossible unless some information can be remembered by an agent that has failed and restarted.
    \end{itemize}
    \item \textbf{Messages:} Can take arbitrarily long to be delivered, can be duplicated, and can be lost, but they are not corrupted.
\end{itemize}
\section{Actors}
Paxos involves three types of actors:
\begin{itemize}
    \item \textbf{Proposers:} Propose values to be agreed upon.
    \item \textbf{Acceptors:} Act as the voting body that decides which value to accept.
    \item \textbf{Learners:} Learn the chosen value once consensus is reached.
\end{itemize}

\subsection*{first problem}
if there isa asingle acceptor, and it crash after accepting a value, the system cannot make progress.
§§§
\chapter{Total Order Broadcast}
Total Order Broadcast (TOB) is a fundamental communication primitive in distributed systems that ensures all processes deliver messages in the same order.

\section{System model}
We consider a distributed system with the following assumptions.
\begin{itemize}
    \item \textbf{Processes:}
    \begin{itemize}
        \item There is a static set of processes $p_1, \dots, p_n$.
        \item Processes can fail by \emph{crash}: a crashed process stops executing its algorithm forever, but they can't behave maliciously.(bizantine failures are not considered here)
        \item A process that never crashes is called a \emph{correct} process.
        \end{itemize}
    \item \textbf{Communication:}Channels between correct processes are \emph{perfect}: messages are not lost, not duplicated, and no fake messages are created.
    \item \textbf{Asynchronous:} there is no known upper bound on message transmission time or processing time.
\end{itemize}

\section{Total Order specification}
TO (Total Order) is composed by 4 specifications:
\begin{itemize}
    \item \textbf{Validity:} If a correct process broadcasts a message $m$, then it eventually delivers $m$.
    \item \textbf{Uniform Agreement:} If a process delivers a message $m$, then all correct processes eventually deliver $m$.
    \item \textbf{Uniform Integrity:} For any message $m$, every process delivers $m$ at most once, and only if $m$ was previously broadcast by its sender.
    \item \textbf{Uniform Total Order:} If two processes $p_i$ and $p_j$ deliver two messages $m$ and $m'$, then $p_i$ delivers $m$ before $m'$ if and only if $p_j$ delivers $m$ before $m'$.
\end{itemize}
Validity parla di consegna assicurata per messaggi validi.
\newline
Uniform Agreement parla di accordo sull'insieme dei messaggi consegnati.
\newline
Uniform Integrity parla di evitare duplicati e messaggi inventati.
\newline
Uniform Total Order parla di accordo sull'ordine esatto di consegna.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imm/Screenshot 2025-11-25 alle 18.09.55.png}
    \caption{Total Order Broadcast properties}
\end{figure}
A Uniform properties is stronger than a non-uniform one because it applies to all processes, not just correct ones.

\section {Non-Uniform Validity-Uniform Integrity}
Such that our system have perfect channel and chra failures, the properties satisfied are:
\newline
NUV (Non-Uniform Validity): If a correct process broadcasts a message $m$, then it eventually delivers $m$.
\newline
UI (Uniform Integrity): For any message $m$, every process delivers $m$ at most once, and only if $m$ was previously broadcast by its sender.
\newline
the properties that are not satisfied are: Agreement and Total Order.
\subsubsection*{Agreement property}
\begin{itemize}
    \item \textbf{Non-Uniform Agreement:} If a CORRECT process delivers a message $m$, then all correct processes eventually deliver $m$.
    \item \textbf{Uniform Agreement:} If a process delivers a message $m$, then all correct processes eventually deliver $m$.
    \newline
    \newline
    The difference is that in Uniform Agreement, the process delivering $m$ can be faulty.The correct processes deliver the same set of messages, while faulty processes may deliver a different set of messages or none at all.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{imm/Screenshot 2025-11-25 alle 18.41.44.png}
        \caption{Non-Uniform Agreement vs Uniform Agreement}
    \end{figure}
    UA: If P3 (faulty process) delivers m2, then P1 and P2 (correct processes) must also deliver m2.
    \newline
    NUA: If P3 (faulty process) delivers m5, it does not imply that P1 and P2 (correct processes) must also deliver m5.
\end{itemize}
\subsubsection*{Total Order property}
\begin{itemize}
    \item \textbf{Strong Uniform Total Order:} if some process deliver message m before m', then a process deliver m' only after m.
    \item \textbf{Weak Uniform Total Order:} If two processes $p_i$ and $p_j$ deliver two messages $m$ and $m'$, then $p_i$ delivers $m$ before $m'$ if and only if $p_j$ delivers $m$ before $m'$.
\end{itemize}
    The difference is that in SUTO, all processes must deliver the same set of messages in the same order, while in WUTO, processes may deliver different sets of messages, but the relative order of any two messages is consistent across processes that deliver both messages.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{imm/Screenshot 2025-11-25 alle 18.48.48.png}
        \caption{Strong Uniform Total Order vs Weak Uniform Total Order}
    \end{figure}
    SUTO: if process p3,delivers message m4 before m5, then process p4 must also deliver m4 before m5.
    \newline
    WUTO: Each process may deliver a different set of messages, but the relative order between any two messages is always the same for processes that deliver both messages.

\begin{itemize}
    \item \textbf{Strong non-Uniform Total Order:} if some CORRECT process deliver message m before m', then a CORRECT process deliver m' only after m.
    \item \textbf{Weak non-Uniform Total Order:} If two CORRECT processes $p_i$ and $p_j$ deliver two messages $m$ and $m'$, then $p_i$ delivers $m$ before $m'$ if and only if $p_j$ delivers $m$ before $m'$.
\end{itemize}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{imm/Screenshot 2025-11-25 alle 19.02.37.png}
        \caption{}
    \end{figure}
    Strong assumptions is more restrictive than weak assumptions (SUTO=>WUTO- SNUTO=>WNUTO).
\section{Examples of Total Order Broadcast Variants}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.42\textwidth]{imm/Screenshot 2025-11-25 alle 19.15.06.png}
    \hfill
    \includegraphics[width=0.42\textwidth]{imm/Screenshot 2025-11-25 alle 19.15.15.png}
    \caption*{UA + SUTO: All processes deliver the same set of messages in the same order. \newline NUA + SUTO: Only correct processes deliver the same set/order; faulty process may miss messages ($m_4$, $m_5$ missing).}
    \vspace{1em}
    \includegraphics[width=0.42\textwidth]{imm/Screenshot 2025-11-25 alle 19.15.26.png}
    \hfill
    \includegraphics[width=0.42\textwidth]{imm/Screenshot 2025-11-25 alle 19.15.40.png}
    \caption*{UA + WUTO: All processes deliver the same set with consistent relative order. \newline NUA + WUTO: Only correct processes deliver the same set with consistent relative order.\newline}
    \vspace{1em}
    \includegraphics[width=0.42\textwidth]{imm/Screenshot 2025-11-25 alle 19.15.48.png}
    \hfill
    \includegraphics[width=0.42\textwidth]{imm/Screenshot 2025-11-25 alle 19.15.56.png}
    \caption*{UA + WNUTO: Correct processes deliver the same set with consistent relative order; faulty process behavior is undefined. \newline NUA + WNUTO: Correct processes deliver the same set with consistent relative order; $m_5$ missing from some processes.}
\end{figure}
\end{document}